<!DOCTYPE html>
<html lang="ja" prefix="og: http://ogp.me/ns#">
<head>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1V1ELMWFTY"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-1V1ELMWFTY');
    </script>

    <meta name="ad-mode" content="adult">
    <script src="/js/ads.js" defer></script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">

    <meta name="description" content="[JP] プロ仕様の2画面動画比較・フォーム分析ツール。シンクロ再生、録画、描画機能でスポーツやダンスのフォームを改善。[EN] Professional side-by-side video analysis tool. Sync, record, and improve your form for sports and dance.">
    <meta name="keywords" content="Form Analysis, Video Sync, Sports Tech, Dance Training, フォーム分析, 動画比較, スポーツトレーニング, シンクロ再生, アプリ">
    <meta name="author" content="Kunifami" >
    <meta property="og:title" content="Form Mirror Pro Sync for iPhone">
    <meta property="og:description" content="Professional video analysis tool for everyone.">
    <meta property="og:type" content="website">

    <title>Form Mirror Sync Pro for iPhone ver 1.1</title>

    <!-- ★★★ HARD SYNC MODE ★★★
         true  : Aを完全マスター、Bは完全従属（業務用同期方式）
         false : 従来方式（※今回は必ずtrue固定で使用）
    -->
    <script>
        const HARD_SYNC = true;
    </script>

    <style>
        :root {
            --primary: #FFCC00;
            --accent: #0A84FF;
            --record: #FF3B30;
            --bg-glass: rgba(15, 15, 15, 0.95);
            --text-main: #FFFFFF;
        }

        body { 
            margin: 0; background: #000; color: var(--text-main); 
            font-family: -apple-system, BlinkMacSystemFont, "Hiragino Sans", sans-serif; 
            overflow: hidden; position: fixed; width: 100%; height: 100%;
            touch-action: none; -webkit-user-select: none;
        }
        
        #mainCanvas { width: 100vw; height: 100vh; display: block; background: #000; }
        
        .fade-ui { transition: opacity 0.3s ease, transform 0.3s ease; opacity: 0; pointer-events: none; }
        .ui-visible { opacity: 1; pointer-events: auto; transform: translateY(0) !important; }

        /* Top Bar */
        .top-bar {
            position: fixed; top: 0; left: 0; right: 0;
            padding: calc(env(safe-area-inset-top) + 10px) 15px 10px;
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            z-index: 100;
            transform: translateY(-100%);
        }

        .icon-btn {
            background: rgba(255,255,255,0.15); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2);
            color: white; width: 44px; height: 44px; border-radius: 12px;
            display: flex; align-items: center; justify-content: center; font-size: 18px; cursor: pointer;
            position: relative;
        }
        .icon-btn.active { background: var(--accent); border-color: var(--accent); }
        .icon-btn.rec-btn { border-color: var(--record); color: var(--record); font-weight: bold; width: auto; padding: 0 15px; gap: 5px; }
        .icon-btn.rec-btn.recording { background: var(--record); color: white; animation: pulse-rec 1s infinite; }

        @keyframes pulse-rec { 
            0% { opacity: 1; } 
            50% { opacity: 0.6; } 
            100% { opacity: 1; } 
        }

        /* ……（CSSはこのまま元コード完全維持、続きは次ブロックで） */
    </style>
</head>

<body>

      <canvas id="mainCanvas"></canvas>

    <!-- Video Elements -->
    <video id="vidA" playsinline webkit-playsinline muted></video>
    <video id="vidB" playsinline webkit-playsinline muted></video>

    <!-- UI -->
    <div class="top-bar fade-ui" id="topBar">
        <div style="display:flex; gap:10px;">
            <div class="icon-btn" id="playBtn">▶</div>
            <div class="icon-btn" id="framePrevBtn">⏮</div>
            <div class="icon-btn" id="frameNextBtn">⏭</div>
        </div>
        <div style="display:flex; gap:10px;">
            <div class="icon-btn rec-btn" id="recBtn">● REC</div>
        </div>
    </div>

    <script>
    // ==============================
    // 基本要素取得
    // ==============================
    const canvas = document.getElementById("mainCanvas");
    const ctx = canvas.getContext("2d");
    const vidA = document.getElementById("vidA");
    const vidB = document.getElementById("vidB");

    const playBtn = document.getElementById("playBtn");
    const framePrevBtn = document.getElementById("framePrevBtn");
    const frameNextBtn = document.getElementById("frameNextBtn");

    let isSeeking = false;
    let syncOffset = 0;  // B = A + syncOffset

    const speeds = [0.25, 0.5, 1.0, 1.5, 2.0];
    let speedIdx = 2;

    // ==============================
    // Canvas resize
    // ==============================
    function resizeCanvas() {
        canvas.width = window.innerWidth * devicePixelRatio;
        canvas.height = window.innerHeight * devicePixelRatio;
        ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // ==============================
    // HARD SYNC 同期関数
    // ==============================
    function syncVideos() {
        if (isSeeking || vidA.paused || vidB.paused) return;

        const master = vidA;
        const slave  = vidB;
        const target = master.currentTime + syncOffset;
        const diff   = slave.currentTime - target;
        const rate   = speeds[speedIdx];

        if (HARD_SYNC) {
            if (Math.abs(diff) > 0.002) {  // 2ms以上ズレたら即補正
                slave.currentTime = target;
            }
            slave.playbackRate = rate;
        } else {
            if (Math.abs(diff) > 0.5) {
                slave.currentTime = target;
            } else {
                slave.playbackRate = rate - diff * 10;
            }
        }
    }

    // ==============================
    // 描画ループ
    // ==============================
    function render() {
        requestAnimationFrame(render);

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const w = canvas.width / 2;
        const h = canvas.height;

        if (vidA.readyState >= 2) {
            ctx.drawImage(vidA, 0, 0, w, h);
        }
        if (vidB.readyState >= 2) {
            ctx.drawImage(vidB, w, 0, w, h);
        }

        // ★同期処理はここだけ
        syncVideos();
    }
    render();

    // ==============================
    // 再生制御（Aマスター）
    // ==============================
    async function togglePlay() {
        if (vidA.paused) {
            const t = vidA.currentTime;
            vidB.currentTime = t + syncOffset; // 先に一致
            await Promise.all([vidA.play(), vidB.play()]);
            playBtn.textContent = "⏸";
        } else {
            vidA.pause();
            vidB.pause();
            playBtn.textContent = "▶";
        }
    }

    playBtn.addEventListener("click", togglePlay);

    // ==============================
    // フレーム送り（A基準）
    // ==============================
    function changeFrame(dir) {
        const fps = 30;
        const step = 1 / fps;
        vidA.currentTime += dir * step;
        vidB.currentTime = vidA.currentTime + syncOffset;
    }

    framePrevBtn.addEventListener("click", () => changeFrame(-1));
    frameNextBtn.addEventListener("click", () => changeFrame(1));

    // ==============================
    // 相対シーク（A基準）
    // ==============================
    function seekRelative(sec) {
        vidA.currentTime += sec;
        vidB.currentTime = vidA.currentTime + syncOffset;
    }

    // 例：キーボード操作（任意）
    document.addEventListener("keydown", e => {
        if (e.key === "ArrowLeft") seekRelative(-1);
        if (e.key === "ArrowRight") seekRelative(1);
        if (e.key === " ") togglePlay();
    });

    </script>

      // ==============================
    // ファイル読み込み
    // ==============================
    function loadVideo(file, videoElem) {
        const url = URL.createObjectURL(file);
        videoElem.src = url;
        videoElem.load();
    }

    // 仮：ドラッグ＆ドロップで動画セット（A左 / B右）
    document.body.addEventListener("dragover", e => e.preventDefault());
    document.body.addEventListener("drop", e => {
        e.preventDefault();
        const files = e.dataTransfer.files;
        if (files.length >= 1) loadVideo(files[0], vidA);
        if (files.length >= 2) loadVideo(files[1], vidB);
    });

    // ==============================
    // シーク終了処理（A基準）
    // ==============================
    function endSeek(target, val) {
        isSeeking = false;
        if (target === "A") {
            vidA.currentTime = parseFloat(val);
            vidB.currentTime = vidA.currentTime + syncOffset;
        } else {
            vidB.currentTime = parseFloat(val);
            syncOffset = vidB.currentTime - vidA.currentTime;
        }
    }

    // ==============================
    // UI フェード制御（タップで表示/非表示）
    // ==============================
    const topBar = document.getElementById("topBar");
    let uiVisible = false;
    let uiTimer = null;

    function showUI() {
        uiVisible = true;
        topBar.classList.add("ui-visible");
        clearTimeout(uiTimer);
        uiTimer = setTimeout(hideUI, 2500);
    }

    function hideUI() {
        uiVisible = false;
        topBar.classList.remove("ui-visible");
    }

    document.addEventListener("click", () => {
        if (uiVisible) hideUI();
        else showUI();
    });

    // ==============================
    // 初期再生速度反映
    // ==============================
    function updatePlaybackRate() {
        const rate = speeds[speedIdx];
        vidA.playbackRate = rate;
        vidB.playbackRate = rate;
    }
    updatePlaybackRate();

    // ==============================
    // 録画（Canvasキャプチャ）
    // ==============================
    let mediaRecorder = null;
    let recordedChunks = [];
    const recBtn = document.getElementById("recBtn");

    recBtn.addEventListener("click", () => {
        if (!mediaRecorder || mediaRecorder.state === "inactive") {
            startRecording();
        } else {
            stopRecording();
        }
    });

    function startRecording() {
        const stream = canvas.captureStream(60);
        recordedChunks = [];
        mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm; codecs=vp9" });

        mediaRecorder.ondataavailable = e => {
            if (e.data.size > 0) recordedChunks.push(e.data);
        };

        mediaRecorder.onstop = saveRecording;
        mediaRecorder.start();
        recBtn.classList.add("recording");
        recBtn.textContent = "■ STOP";
    }

    function stopRecording() {
        mediaRecorder.stop();
        recBtn.classList.remove("recording");
        recBtn.textContent = "● REC";
    }

    function saveRecording() {
        const blob = new Blob(recordedChunks, { type: "video/webm" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "form_mirror_record.webm";
        a.click();
        URL.revokeObjectURL(url);
    }

    </script>
</body>
</html>
